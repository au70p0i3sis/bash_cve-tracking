#!/usr/bin/env bash

#
# Queries the National Vulnerability Database's Api to retrieve
# a list of cve's for a given cpe (Common Platform Enumerations, v2.3)
#
# How to use:
# cve_query.sh [OPTION]... CPE
#
# Options:
# -a INT	set age range in days (120 is the default and max accepted by api)
# -d		output to database (hardcoded in script)
# -h 		print help
# -j 		output in json (default:human readable)
# -r		run query and return raw result, no parsing or filtering
#
# example: 
#	retrieve cves published in the last 30 days and output into database
#	cve_query.sh -a 30 -d "cpe:2.3:a:apache:log4j:2.0:-:*:*:*:*:*:*"
#
# NOTE: queries without an API key will be time restricted to meet the NVD's requirements
# see: https://nvd.nist.gov/general/news/API-Key-Announcement
# API key can get set with environment variable API_KEY

## DEFAULT GLOBAL VARS ##
baseurl="https://services.nvd.nist.gov/rest/json/cves/1.0"
maxage=120  # how far back to search, api accepts 120 day ranges
cpe="${BASH_ARGV[0]}"
output_mode="human" # options: human, json, database
dbfile="nvd-api.db" # sqlite database

table_schema="CREATE TABLE cves_tracked(
		id INTEGER PRIMARY KEY,
		cve_id TEXT,
		cpe	TEXT,
		date_pub DATE,
		date_lastmod DATE,
		description TEXT,
		refers	TEXT,
		severity	TEXT,
		comments	TEXT
);"

query_form() {
	# usage: query_form <cpeString> <startDate> <endDate>
	local cpeq="cpeMatchString=$1"
	# date format: yyyy-MM-ddTHH:mm:ss:SSS Z 
	# full date example: modStartDate=2021-08-04T13:00:00:000 UTC%2B01:00&modEndDate=2021-10-22T13:36:00:000 UTC%2B01:00
	declare datestart dateend dateq query
	datestart="${2}T13:00:00:000%20UTC%2B01:00"
	dateend="${3}T13:00:00:000%20UTC%2B01:00"
	dateq="pubStartDate=${datestart}&pubEndDate=${dateend}"
	query="${baseurl}?${cpeq}&${dateq}"
	# if api key 
	if [[ -z "${API_KEY}" ]]; then
		echo "$query"
	else # add validation
		query="${query}&apiKey=${API_KEY}"
		echo "$query"
	fi
} 

query_run() {
	declare json_result curl_return status_code 
	#json_result=$(curl -s "$1")
	#echo "$json_result"
	curl_return=$(curl -s --connect-timeout 5 "$1" -w "\n%{response_code}\n")	
	status_code=$(echo "$curl_return"| tail -n 1)
	if [[ ! "$status_code" == "200" ]]; then 
		echo "ERROR: Server returned status $status_code"
	 	exit 1
	fi
	json_result=$(echo "$curl_return" | head -n 1)
	echo "$json_result"
}

json_extract2b64(){ 
	# extracts desired json data, outputs in space seperated string
	# of base64 encoded json items
	declare qresult num_results cves_full json_out
	qresult="$1"
	#items="$(echo "$result" | jq --raw-output '.result.CVE_ITEMS[]')"
	num_results="$(echo "$qresult" | jq --raw-output '.totalResults')"
	if [[ "$num_results" -eq 0 ]]; then 
		echo "none"
	else 
		cves_full=$(echo "$qresult" | jq -c '.result | .CVE_Items[]')
		json_out=$(echo "$cves_full" |  jq -c '{
			cve_id: .cve.CVE_data_meta.ID,
			pub_date: .publishedDate ,
			description: .cve.description.description_data[].value,
			severity: .impact.baseMetricV3.cvssV3.baseSeverity,
			reference: [.cve.references.reference_data[].url]
			} | .')
		declare -a json_results_b64
		while read -r jline; do 
			entry_b64="$(echo "$jline" | base64 | tr -d '[:space:]')"
			json_results_b64+=("$entry_b64")
		done <<< "$json_out"
		echo "${json_results_b64[@]}"
	fi
}

output_human(){
	declare _cve _pubdate _descr _severity _references
	for entry in $@; do # don't quote $@, we need split elements
		entry="$(echo "$entry" | base64 -d)"
		_cve="$(echo "$entry" | jq '.cve_id')"
		_pubdate="$(echo "$entry" | jq '.pub_date')"
		_descr="$(echo "$entry" | jq '.description')"
		_severity="$(echo "$entry" | jq '.severity')"
		_references="$(echo "$entry" | jq '.reference[]')"
		echo
		echo "CVE: $_cve"
		echo "Date Published: $_pubdate"
		echo "Severity: $_severity"
		echo "Description: $_descr"
		echo "References: $_references"
		echo
	done
}

output_json(){
	echo "${@// /}" | base64 -d
}

db_check(){
	# validates the existence of database and proper table schema
	declare ret_sch
	if [[ -e "$dbfile" ]]; then 
		ret_sch="$(sqlite3 $dbfile ".schema cves_tracked")"
		if [[ "$ret_sch" == "$table_schema" ]]; then 
			#echo "schema check passed"
			return 0
		else # if dbfile exists but doesn't have correct table schema 
			echo "$dbfile exists but has incorrect schema, fixing now..."
			sqlite3 "$dbfile" "DROP TABLE cves_tracked" 2>/dev/null
			sqlite3 "$dbfile" "$table_schema"
		fi
	else # if no dbfile 
		echo "cannot access $dbfile" 
		read -rp "create $dbfile now? [y/n]: " create_resp
		if [[ "${create_resp,,}" == "y" ]]; then 
			sqlite3 "$dbfile" "$table_schema"
		else
			echo "exiting..."
			exit 1
		fi
	fi
}

output_db(){
	db_check || exit 1
	declare _cve _pubdate _descr _severity _references
	for entry in $@ ; do 
		entry="$(echo "$entry" | base64 -d)"
		_cve="$(echo "$entry" | jq '.cve_id')"
		_pubdate="$(echo "$entry" | jq '.pub_date')"
		_descr="$(echo "$entry" | jq '.description')"
		_severity="$(echo "$entry" | jq '.severity')"
		_references="$(echo "$entry" | jq '.reference[]')"
		# check for duplicates
		dup_query="select * from cves_tracked WHERE cve_id= '$_cve';"
		resp="$(sqlite3 "$dbfile" "$dup_query")"
		if [[ "$resp" == "" ]] ; then
			echo "storing $_cve in $dbfile table cves_tracked"
			sqlc="insert into cves_tracked(
				cve_id, 
				cpe,
				date_pub,
				date_lastmod, 
				description, 
				refers, 
				severity, 
				comments
			)
			values(
				'$_cve',
				'$cpe',
				'$_pubdate',
				'null',
				$_descr, 
				'null',
				'$_severity', 
				'null'
			);"
			sqlite3 "$dbfile" "$sqlc"
		else
			echo "$_cve already in database...skipping"
		fi
	done
}

db_init(){
	# create cve table
	touch "$dbfile"
	sqlite3 "$dbfile" "create table cves_tracked(
		id INTEGER PRIMARY KEY, 
		cve_id TEXT, 
		cpe	TEXT,
		date_pub DATE,
		date_lastmod DATE,
		description TEXT,
		refers	TEXT,
		severity	TEXT,
		comments	TEXT
	);"
}

print_help(){
	echo "Queries the National Vulnerability Database's Api to retrieve"
	echo "a list of cve's for a given cpe (Common Platform Enumerations, v2.3)"	
	echo
	echo "How to use:"	
	echo "cve_query.sh [OPTION]... CPE" 
	echo
	echo "Options:"
	echo "-a INT	set age range in days (120 is the default and max accepted by api)"
	echo "-d		output to database (hardcoded in script)"
	echo "-h 		print help"
	echo "-j 		output in json (default:human readable)"
	echo "-r		run query and return raw result, no parsing or filtering"
	echo
	echo "example: cve_query.sh -a 30 -d \"cpe:2.3:a:apache:log4j:2.0:-:*:*:*:*:*:*\""
	echo
	echo "NOTE: queries without an API key will be time restricted to meet the NVD's requirements"
	echo "see: https://nvd.nist.gov/general/news/API-Key-Announcement"
	echo "API key can get set with environment variable API_KEY"
}

main(){
	begin_date="$(date --date="$maxage days ago" +%Y-%m-%d)"
	end_date="$(date +%Y-%m-%d)"
	q="$(query_form "$cpe" "$begin_date" "$end_date")"
	if [[ "$output_mode" == "raw" ]];  then 
		query_run "$q"
	else 
		b64_entries="$(json_extract2b64 "$(query_run "$q")")"
		if [[ "$b64_entries" == "none" ]]; then 
			echo "returned 0 cves"
			exit 0
		else 
			if [[ "$output_mode" == "json" ]]; then 
				output_json "$b64_entries" || exit 1
			elif [[ "$output_mode" == "db" ]]; then 
				output_db "$b64_entries" || exit 1 
			else 
				output_human "$b64_entries" || exit 1
			fi
		fi
	fi
}

while getopts ":a:dhjr?" opt; do 
	case "$opt" in 
		a) 	# validate the max age input
			if [[ "${OPTARG//[^0-9]/}" == "$OPTARG" ]]; then 
				if [[ $OPTARG -gt 120 ]] || [[ "$OPTARG" -lt 1 ]]; then
					echo "max age must be an int between 1-120"
					exit 1
				else
					maxage=$OPTARG
				fi
			else
				echo "max age must be an int between 1-120"
				exit 1
			fi
			;;
		d) output_mode="db" ;;
		h) print_help && exit ;;
		j) output_mode="json" ;;
		r) output_mode="raw" ;;
		\?) echo "invalid option -$OPTARG" && print_help && exit 1 ;;
	esac
done

if [[ ! "${#@}" -gt 0 ]]; then 
	print_help 
	exit 1
else
	input_cpe="${BASH_ARGV[0]}"
	# lazy validate cpe argument
	if [[ "$input_cpe" =~ cpe:2.3: ]]; then 
		main "$input_cpe"
	else
		echo "invalid cpe, should be in the format \"cpe:2.3:*:*:*:*:*:*:*:*:*:*:*\""
	fi
fi



