#!/usr/bin/env bash

#################################################################
#
# A helper scipt to query the NVD's (National Vulnerability Database)
# API to retrieve possible cpes (Common Platform Enumerations) for a given software.
# see: 
#	https://nvd.nist.gov/products/cpe
#	https://nvd.nist.gov/developers/products
# 
# can run in 2 modes:
#
#	Interactive mode can will present info on each returned cpe and let you pick which
#	to append to the specified file (either hardcoded in $outfile or
#	set with the -o <outfile> flag.
#
# 	Minimal mode will only output the list of returned cpes to stdout. 
#
# 	For both modes, the API will return a max 20 results, specify software versions
# 	for better results. 	
#
# How to use:
# cpe_find.sh [OPTION]... PROGRAM [VERSION]
#
# optional arguments:
# -h 		print help
# -i 		interactive mode: show info on query results, select results to append cpes to the outfile
# -m 		minimal, non-interactive mode: returns all cpe's matching query (up to 20 results)
# -o file 	override hardcoded output file
#
# the nvd api will return a max 20 results, specify a version number in your search for more precise results
#
# example: cpe_find.sh -io outfile.txt rsync 3.2.5

############################################################


outfile="cpes.txt"
baseurl="https://services.nvd.nist.gov/rest/json/cpes/1.0"

query_cpes(){ # queries api and human prints results into a global array json_results_b64
	declare  query termstring curl_return status_code
	query="${baseurl}?keyword="
	for searchterm in "$@"; do 
		termstring="$termstring$searchterm%20"
	done
	query="$query$termstring"
	if [[ -n "${API_KEY}" ]]; then 
		query="${query}&apiKey=${API_KEY}"
	fi
	curl_return=$(curl -s --connect-timeout 5 "$query" -w "\n%{response_code}\n")
	status_code=$(echo "$curl_return"| tail -n 1)
	if [[ ! "$status_code" == "200" ]]; then 
		echo "ERROR: Server returned status $status_code"
	 	exit 1
	fi
	declare json_result
	declare -g total_returned
	json_result=$(echo "$curl_return" | head -n 1)
	total_returned="$(echo "$json_result" | jq -c '.totalResults')"
	if [[ ! "$total_returned" -gt 0 ]]; then  
		echo "returned 0 results"
		exit 1 
	fi
	declare extracted_json 
	extracted_json=$(
		echo "$json_result" | jq --compact-output '.result.cpes[] | 
		{
		cpe:.cpe23Uri, 
		title:.titles[].title, 
		deprecated: .deprecated, 
		lastmodified: .lastModifiedDate
		}')
	# convert each json item into base64 and insert into bash array
	declare -ga json_results_b64
	while read -r jline; do 
		entry_b64="$(echo "$jline" | base64 | tr -d '[:space:]')"
		json_results_b64+=("$entry_b64")
	done <<< "$extracted_json"
}

json2human_interact(){
	# interactive entry selection and output to file
	printf "\n%s\n\n" "found ${#json_results_b64[*]} result(s):"
	# get each item in json and output in easily readable format
	local i=0
	for entry in ${json_results_b64[*]}; do 
		((++i))
		entry="$(echo "$entry" | base64 -d)"
		declare _cpe _title _depre #_lastmod
		_cpe=$(echo "$entry" | jq '.cpe')
		_title=$(echo "$entry" | jq '.title')
		_depre=$(echo "$entry" | jq '.deprecated')
		#_lastmod=$(echo "$entry" | jq '.lastmodified')
		printf '%s: %s %s' "$i" "$_title"  "$_cpe"
		#echo "$_title"
		#echo "cpe: $_cpe"
		#echo "last modified: $_lastmod"
		if [[ "$_depre" == "true" ]]; then  
			printf "	WARNING: deprecated"
		fi
		printf '\n'
	done
}

json2human_minimal(){
	# output only the cpes
	local i=0
	for entry in ${json_results_b64[*]}; do 
		((++i))
		echo "$entry" | base64 -d | jq --raw-output '.cpe'
	done
}
 
get_input(){
	echo
	input_success="false"
	while [[ $input_success == "false" ]]; do 
		read -r -p "enter entry number(s) to output (eg: 1 3 9) or 'exit' to leave: " input_raw
		if [[ "${input_raw,}" == "exit" ||  "${input_raw,}" == "q" ]]; then 
			echo "exiting"
			exit 0
		elif [[ ! "$input_raw" == "${input_raw//[^0-9| +]/}" ]]; then 
			echo "numbers only"
		else
			mapfile input_nums < <(echo "$input_raw")
			for n in ${input_nums[*]}; do 
				append_cpe "$n"
			done
			exit
		fi
	done
}

append_cpe(){  # appends selected cpe's to output file
	local x="$1"
	x=$((x-1))
	if [[ "$x" -gt "$total_returned" ]]; then 
		echo "FALIED to find entry $1, number higher than available entries"
	else
		declare r
		r="$(echo "${json_results_b64[$x]}" | base64 -d | jq '.cpe' | tr -d '\"')"
		if [[ "${#r}" -gt 1 ]] && [[ "$r" =~ cpe:2.3 ]]; then 
			echo
			echo "$r" >> "${outfile_opt:-$outfile}"
			echo "appended $r to ${outfile_opt:-$outfile}"
		else
			echo
			echo "couldn't retrieve entry #$1, is it listed above?"
		fi
	fi
}

print_help(){
	echo "A helper scipt to query the NVD's (National Vulnerability Database)"
	echo "API to retrieve possible cpes (Common Platform Enumerations) for a given software."
	echo "Information about CPEs: https://nvd.nist.gov/products/cpe"
	echo
	echo "How to use:"
	echo "cpe_find.sh [OPTION]... PROGRAM [VERSION]" 
	echo
	echo "optional arguments:"
	echo "-h 		print help"
	echo "-i 		interactive mode: show info on query results, select results to append cpes to the outfile"
	echo "-m 		minimal, non-interactive mode: returns all cpe's matching query (up to 20 results)"
	echo "-o file 	override hardcoded output file"
	echo
	echo "the nvd api will return a max 20 results, specify a version number in your search for more precise results"
	echo
	echo "example: cpe_find.sh -io outfile.txt rsync 3.2.5"
	echo
	exit
}

main(){
	query_cpes "$@"
	if [[ "$output_mode" == "minimal" ]] && [[ -n "$outfile_opt" ]]; then
		json2human_minimal | tee -a "$outfile_opt"
	elif [[ "$output_mode" == "minimal" ]]; then 
		json2human_minimal
	else
		json2human_interact
		get_input
		append_cpe
	fi
}

output_mode="minimal"
while getopts ":himo:" opt; do 
	case "$opt" in 
		h) 
			print_help ;;
		i) 
			output_mode="interactive" ;;
		m) 
			echo "executing in minimal mode"
			output_mode="minimal" ;;	
		o)  
			echo "outputting to file $OPTARG" 
			outfile_opt="$OPTARG"
			;;
		\?) 
			echo "invalid option -$OPTARG" && exit 1 && print_help ;;
	esac
done

if [[ ! "${#@}" -gt 0 ]]; then 
	print_help 
	exit 1
else
	declare -a input_terms	
	# select only non-option and optargs for search terms to pass
	arrlen=${#BASH_ARGV[@]}
	for ((i=arrlen;i>=1;i--)); do 
		arg="${BASH_ARGV[((i-1))]}"
		if [[ ! "$arg" == "$outfile_opt" && ! "$arg" =~ ^- ]]; then 
			input_terms+=("$arg")
		fi
	done
	echo "searching for results matching: ${input_terms[*]}"
	main "${input_terms[@]}"
fi
